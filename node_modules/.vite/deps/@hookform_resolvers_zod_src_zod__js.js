import {
  appendErrors,
  get,
  set
} from "./chunk-F6GKDAPE.js";
import "./chunk-NVDSUZN5.js";
import "./chunk-ZC22LKFR.js";

// node_modules/@hookform/resolvers/dist/resolvers.mjs
var t = function(e, t2, i2) {
  if (e && "reportValidity" in e) {
    var n2 = get(i2, t2);
    e.setCustomValidity(n2 && n2.message || ""), e.reportValidity();
  }
};
var i = function(r, e) {
  var i2 = function(i3) {
    var n3 = e.fields[i3];
    n3 && n3.ref && "reportValidity" in n3.ref ? t(n3.ref, i3, r) : n3.refs && n3.refs.forEach(function(e2) {
      return t(e2, i3, r);
    });
  };
  for (var n2 in e.fields)
    i2(n2);
};
var n = function(t2, n2) {
  n2.shouldUseNativeValidation && i(t2, n2);
  var f = {};
  for (var s in t2) {
    var u = get(n2.fields, s), c = Object.assign(t2[s] || {}, { ref: u && u.ref });
    if (a(n2.names || Object.keys(t2), s)) {
      var l = Object.assign({}, o(get(f, s)));
      set(l, "root", c), set(f, s, l);
    } else
      set(f, s, c);
  }
  return f;
};
var o = function(r) {
  return Array.isArray(r) ? r.filter(Boolean) : [];
};
var a = function(r, e) {
  return r.some(function(r2) {
    return r2.startsWith(e + ".");
  });
};

// node_modules/@hookform/resolvers/zod/src/zod.ts
var isZodError = (error) => error.errors != null;
var parseErrorSchema = (zodErrors, validateAllFieldCriteria) => {
  const errors = {};
  for (; zodErrors.length; ) {
    const error = zodErrors[0];
    const { code, message, path } = error;
    const _path = path.join(".");
    if (!errors[_path]) {
      if ("unionErrors" in error) {
        const unionError = error.unionErrors[0].errors[0];
        errors[_path] = {
          message: unionError.message,
          type: unionError.code
        };
      } else {
        errors[_path] = { message, type: code };
      }
    }
    if ("unionErrors" in error) {
      error.unionErrors.forEach(
        (unionError) => unionError.errors.forEach((e) => zodErrors.push(e))
      );
    }
    if (validateAllFieldCriteria) {
      const types = errors[_path].types;
      const messages = types && types[error.code];
      errors[_path] = appendErrors(
        _path,
        validateAllFieldCriteria,
        errors,
        code,
        messages ? [].concat(messages, error.message) : error.message
      );
    }
    zodErrors.shift();
  }
  return errors;
};
var zodResolver = (schema, schemaOptions, resolverOptions = {}) => async (values, _, options) => {
  try {
    const data = await schema[resolverOptions.mode === "sync" ? "parse" : "parseAsync"](values, schemaOptions);
    options.shouldUseNativeValidation && i({}, options);
    return {
      errors: {},
      values: resolverOptions.raw ? values : data
    };
  } catch (error) {
    if (isZodError(error)) {
      return {
        values: {},
        errors: n(
          parseErrorSchema(
            error.errors,
            !options.shouldUseNativeValidation && options.criteriaMode === "all"
          ),
          options
        )
      };
    }
    throw error;
  }
};
export {
  zodResolver
};
//# sourceMappingURL=@hookform_resolvers_zod_src_zod__js.js.map
